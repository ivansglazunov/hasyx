/**
 * Hasyx configuration file management
 * Manages hasyx.config.json with environment-specific variables
 */

import fs from 'fs-extra';
import path from 'path';
import Debug from './debug';

const debug = Debug('hasyx-config');

export interface HasyxConfigEnvironment {
  [key: string]: string;
}

export interface HasyxConfig {
  global?: HasyxConfigEnvironment;
  local?: HasyxConfigEnvironment;
  dev?: HasyxConfigEnvironment;
  prod?: HasyxConfigEnvironment;
  [key: string]: HasyxConfigEnvironment | undefined;
}

export const DEFAULT_ENVIRONMENTS = ['local', 'dev', 'prod'] as const;
export type DefaultEnvironment = typeof DEFAULT_ENVIRONMENTS[number];

/**
 * Get the path to hasyx.config.json in the current working directory
 */
export function getConfigPath(): string {
  return path.join(process.cwd(), 'hasyx.config.json');
}

/**
 * Check if hasyx.config.json exists
 */
export function configExists(): boolean {
  return fs.existsSync(getConfigPath());
}

/**
 * Read hasyx.config.json
 * Returns empty config if file doesn't exist
 */
export function readConfig(): HasyxConfig {
  const configPath = getConfigPath();

  if (!fs.existsSync(configPath)) {
    debug('Config file not found, returning empty config');
    return {};
  }

  try {
    const config = fs.readJsonSync(configPath);
    debug('Config loaded successfully');
    return config;
  } catch (error) {
    console.error('❌ Failed to parse hasyx.config.json:', error);
    debug('Failed to parse config:', error);
    return {};
  }
}

/**
 * Write hasyx.config.json
 */
export function writeConfig(config: HasyxConfig): void {
  const configPath = getConfigPath();

  try {
    fs.writeJsonSync(configPath, config, { spaces: 2 });
    debug('Config written successfully');
  } catch (error) {
    console.error('❌ Failed to write hasyx.config.json:', error);
    debug('Failed to write config:', error);
    throw error;
  }
}

/**
 * Get list of all environments defined in config
 */
export function getEnvironments(config: HasyxConfig): string[] {
  return Object.keys(config).filter(key => key !== 'global');
}

/**
 * Get merged environment variables for a specific environment
 * Merges global variables with environment-specific variables
 */
export function getEnvironmentVariables(
  config: HasyxConfig,
  environment: string
): Record<string, string> {
  const global = config.global || {};
  const envVars = config[environment] || {};

  // Environment-specific variables override global
  return { ...global, ...envVars };
}

/**
 * Set a variable in a specific environment
 */
export function setEnvironmentVariable(
  config: HasyxConfig,
  environment: string,
  key: string,
  value: string
): HasyxConfig {
  const newConfig = { ...config };

  if (!newConfig[environment]) {
    newConfig[environment] = {};
  }

  newConfig[environment] = {
    ...newConfig[environment],
    [key]: value
  };

  return newConfig;
}

/**
 * Remove a variable from a specific environment
 */
export function removeEnvironmentVariable(
  config: HasyxConfig,
  environment: string,
  key: string
): HasyxConfig {
  const newConfig = { ...config };

  if (newConfig[environment]) {
    const envCopy = { ...newConfig[environment] };
    delete envCopy[key];
    newConfig[environment] = envCopy;
  }

  return newConfig;
}

/**
 * Create a default config with standard environments
 */
export function createDefaultConfig(): HasyxConfig {
  return {
    global: {
      // Example: persistent tokens that apply to all environments
      // ACCESS_TOKEN: ""
    },
    local: {
      PORT: '3000',
      HASURA_URL: 'http://localhost:8080',
      NODE_ENV: 'development'
    },
    dev: {
      PORT: '3001',
      HASURA_URL: 'https://dev.example.com',
      NODE_ENV: 'development'
    },
    prod: {
      PORT: '80',
      HASURA_URL: 'https://api.example.com',
      NODE_ENV: 'production'
    }
  };
}

/**
 * Apply environment variables to .env file
 * Replaces the entire contents of .env with the selected environment
 */
export function applyEnvironmentToEnvFile(
  config: HasyxConfig,
  environment: string
): void {
  const envPath = path.join(process.cwd(), '.env');
  const vars = getEnvironmentVariables(config, environment);

  const lines = Object.entries(vars).map(([key, value]) => {
    // Handle values that need quotes
    if (value.includes(' ') || value.includes('#')) {
      return `${key}="${value}"`;
    }
    return `${key}=${value}`;
  });

  const content = [
    `# Environment: ${environment}`,
    `# Generated by hasyx env command at ${new Date().toISOString()}`,
    `# DO NOT EDIT THIS FILE DIRECTLY - use hasyx.config.json instead`,
    '',
    ...lines,
    ''
  ].join('\n');

  try {
    fs.writeFileSync(envPath, content, 'utf-8');
    debug(`Applied ${environment} environment to .env`);
    console.log(`✅ Applied ${environment} environment to .env`);
  } catch (error) {
    console.error('❌ Failed to write .env file:', error);
    debug('Failed to write .env:', error);
    throw error;
  }
}

/**
 * Read current .env file and parse variables
 */
export function readEnvFile(): Record<string, string> {
  const envPath = path.join(process.cwd(), '.env');

  if (!fs.existsSync(envPath)) {
    return {};
  }

  const content = fs.readFileSync(envPath, 'utf-8');
  const vars: Record<string, string> = {};

  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;

    const idx = trimmed.indexOf('=');
    if (idx <= 0) continue;

    const key = trimmed.substring(0, idx).trim();
    let value = trimmed.substring(idx + 1).trim();

    // Remove quotes if present
    if ((value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }

    vars[key] = value;
  }

  return vars;
}

/**
 * Migrate existing .env to hasyx.config.json
 * Adds variables to the specified environment
 */
export function migrateEnvToConfig(
  targetEnvironment: string = 'local'
): HasyxConfig {
  const existingVars = readEnvFile();
  let config = configExists() ? readConfig() : createDefaultConfig();

  if (Object.keys(existingVars).length === 0) {
    debug('No variables found in .env to migrate');
    return config;
  }

  // Merge with existing environment
  config[targetEnvironment] = {
    ...config[targetEnvironment],
    ...existingVars
  };

  debug(`Migrated ${Object.keys(existingVars).length} variables to ${targetEnvironment}`);
  return config;
}
