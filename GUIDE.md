# Hasyx — план статьи для Хабра и контент‑чеклисты

Этот файл — рабочий план будущей статьи на Хабре: структура разделов и минимально необходимый контент (скриншоты, короткие видео/GIF, примеры кода и команд), без которого материал не «заработает» и не соберёт интерес аудитории.

## 1) TL;DR: что такое Hasyx
Коротко: «Next.js + Hasura + Auth + CLI + PWA + платежи + AI» — стартуем прод за часы, без изобретения велосипеда.

- [ ] 1–2 предложения ценности (чем Hasyx отличается от «стартовать с нуля»)
- [ ] Ссылка на демо (если публичная), ссылка на репозиторий
- [ ] Мини‑схема архитектуры (PNG/SVG, 1 картинка) с подписями основных блоков

## 2) Для кого и зачем
К кому обращаемся и какие кейсы решаем: MVP, внутренние инструменты, интеграции, боты.

- [ ] 3–4 кратких «кейса использования» (по 1–2 строки)
- [ ] Табличка «на Hasyx vs с нуля» (время, риски, поддержка) — 5–7 пунктов

## 3) Архитектура одним взглядом
Как устроено: Next.js, Hasura/Postgres, Auth, Files/Storage, Events/Schedule, Payments, AI, Telegram, PWA, Nginx/SSL.

- [ ] Диаграмма архитектуры (1 картинка, уровни: клиент → бэкенд → БД/шины/внешние сервисы)
- [ ] Подпись к каждому блоку (в 1–2 пункта)

## 4) Быстрый старт: с нуля до «Hello»
Hasyx можно применить если у вас уже есть Next.js (например созданное в v0.dev) приложение или вы хотите создать новое.

```sh
# Делает директорию hasyx проектом, мягко.
npx hasyx init
# Появятся, быбазовые конфигурационные файлы как tsconfig.json, jest.config.mjs, .gitignore...
# Тонкие app/api/** роуты для поддержки авторизации, ботов, уведомлений, платежей...
# Технические диагностические страницы app/hasyx/** и пустая шаблонная app/page.tsx
npx hasyx init --force # силовой способ, что бы вернуть измененные вами файлы к изначальному состоянию
```

В принципе, приложение уже будет работать если его запустить, даже без базы данных, и т. д.
```sh
PORT=3000 npm run dev # запуск в режиме разработки
npm run build; PORT=3000 npm start # собрать server-based версию в директории ./.next и запустить
npm run client # собрать static client-only версию в папку ./client
npm run build:android; npm run open:android # собрать и открыть в Android Studio приложение
npm run build:ios; npm run open:ios # собрать и открыть в XCode
```

- [ ] Команда установки/подготовки окружения (Node/PNPM и пр.)
- [ ] Инициализация проекта через CLI (снимок экрана/terminal GIF ≤ 20с)
- [ ] Запуск dev‑сервера, переход в браузер
- [ ] Скрин первого экрана «приложение поднято»

## 5) Конфигурация и CLI `npm run config`/`npx hasyx config`
Но вся сила в инфраструктуре! Hasyx предоставляет конфигуратор хранящий всю конфигурацию в `hasyx.config.json` и отражающий выбранный вариант конфигурации в `.env` и `docker-compose.yml`.

Структура `hasyx.config.json`:
```json
{
  "variant": "variantName", // одно из названий вариантов конфигурации заданных ниже
  "variants": {
    "variantName": {
      // выбор заранее сконфигурированных свойств которые должны быть активны для данного варианта
      "optionName": "optionVariantName"
      // ...
    },
  },
  // все те опции которые в тех или иных вариантах настроены и моут быть доступны в разных окружениях в вашем проекте, например как "telegram" или "openrouter"
  "optionName": {
    // конкретный вариант настройки, например под определенное окружение как "prop"
    "optionVariantName": {},
  },
}
```

А так-же для удобства взаимодействия с инфраструктурой есть команды синхронизации environments/secrets с инфраструктурой:

- ❌ `npm run gitpod`
- ❌ `npm run vercel`
- ❌ `npm run github`

- [ ] Фрагмент `hasyx.config.json` (3–5 ключевых поля с краткими комментариями)
- [ ] Табличка/список топ‑команд CLI (init, generate, migrate, run, build, deploy…)
- [ ] GIF/видео ≤ 30–40с: генерация фичи/модуля из CLI и результат в коде
 - [ ] Важно: конфигурация изменяется через `npx hasyx config`; файлы `.env` и `docker-compose.yml` автогенерируются и не должны редактироваться вручную

## 6) Аутентификация и роли
Логин/регистрация, провайдеры, роли/политики.

- [ ] Скрин экрана логина (форма/SSO, если подключено)
- [ ] Кусок кода/конфига с включением провайдеров (e.g. credentials/SMS)
- [ ] Мини‑пример «проверки роли» на стороне клиента/сервера

## 7) GraphQL через Hasura (и proxy)
Как получать/менять данные, и где проходят права.

- [ ] Скрин Hasura Console: таблица и permissions
- [ ] Пример запроса/мутации через proxy (код, 5–10 строк)
- [ ] Короткий пример «role‑based access» (что видит user vs admin)

## 8) База данных и генератор сущностей
Как из модели быстро получить таблицы/CRUD/типизацию.

- [ ] Команда генератора (и что создаётся на выходе)
- [ ] Пример миграции (минимальный diff)
- [ ] Скрин: новая таблица/отношения в Hasura Console

## 9) Файлы и хранилище
Загрузка/хранение/раздача файлов, лимиты, права.

- [ ] Пример загрузки файла (API‑хэндлер + простой UI)
- [ ] Скрин: файл в сторадже/интерфейсе админки
- [ ] Короткий список «рекомендации по лимитам/безопасности»

## 10) События, Cron и фоновые задачи
Где запускать периодические/долгие операции.

- [ ] Пример расписания (фрагмент cron/задачи)
- [ ] Скрин: логи выполнения/повторная попытка
- [ ] Микро‑метрики: время выполнения/кол-во задач

## 11) Уведомления (Telegram/Firebase/проч.)
Единый способ отправки нотификаций пользователям.

- [ ] Пример `notify.send(...)` (или аналог) для Telegram/Push
- [ ] Скрин: доставленное сообщение
- [ ] Табличка «канал → ограничения/стоимость/когда использовать»

## 12) Платежи (Т‑Банк, Тинькофф)
Минимальный happy‑path: инициировать, оплатить, проверить статус, возврат.

- [ ] Диаграмма последовательности (инициация → редирект/виджет → вебхук → успех)
- [ ] Пример кода и конфиг переменных окружения
- [ ] Скрин: успешная оплата/чек или ответ шлюза

## 13) AI‑интеграции (OpenRouter/Ollama)
Как добавить AI‑фичу: серверный экшен, лимиты, цены.

- [ ] Пример server‑action/route для запроса к модели
- [ ] Скрин: UI ответа (чат/форма)
- [ ] Короткая таблица «модели → стоимость/лимиты/когда какую»

## 14) Telegram: бот, Web App, вебхуки
Подключение бота/веб‑приложения, жизненный цикл вебхука.

- [ ] Скрин: Web App внутри Telegram
- [ ] Пример webhook‑route (5–10 строк)
- [ ] Список «частые ошибки/советы» (таймауты, подписи, секреты)

## 15) PWA: офлайн и установка на рабочий стол
Как включить и что получит пользователь.

- [ ] Скрин: install‑prompt и иконка на рабочем столе
- [ ] Короткий отчёт Lighthouse (PWA секция)
- [ ] Чеклист манифеста/иконок/кеша

## 16) Логи и мониторинг
Что и где смотреть в проде: ошибки, метрики, трассировки.

- [ ] Пример «tail logs»/просмотр ошибок
- [ ] Скрин/пример дашборда (если есть интеграция)
- [ ] Сводка «какие алерты поставить в первую очередь»

## 17) Docker, Nginx, SSL, Subdomain
Мини‑гайд по продакшен‑обвязке.

- [ ] `docker-compose up` (минимальная конфигурация) — фрагмент
- [ ] Nginx конфиг‑сниппет с proxy + HTTP→HTTPS, HSTS
- [ ] Скрин/лог успешного получения сертификата (certbot/lego)

## 18) Шаги деплоя в продакшен
Последовательность, переменные окружения, проверка и откат.

- [ ] Чеклист env‑переменных (секреты, URL, токены)
       (справочный; переменные управляются конфигуратором и попадают в автогенерируемый `.env`)
- [ ] Smoke‑тесты (3–5 пунктов: логин, CRUD, платеж, уведомление)
- [ ] План отката (1–2 абзаца: БД миграции, версии образов)

## 19) Real‑time и туннели (WebSocket/WSTunnel)
Когда нужен realtime и как это включить/отладить локально.

- [ ] Пример минимальной realtime‑фичи (подписка/эвент)
- [ ] Скрин: работающий realtime UI
- [ ] Настройки туннеля для локальной/облачной отладки

## 20) Диаграммы/редакторы (Cytoscape/Renderer)
Как быстро собрать визуальный редактор/диаграммы внутри приложения.

- [ ] Скрин: готовая диаграмма/редактор
- [ ] Фрагмент конфигурации/рендерера (5–10 строк)
- [ ] Список «ограничения/перформанс/хранилище»

## 21) Локализация и i18n
Добавление нового языка и переключатель UI.

- [ ] Пример JSON‑файла переводов (2–3 ключа)
- [ ] Скрин: переключатель языка в интерфейсе
- [ ] Чеклист «как добавить новый язык шаг за шагом»

## 22) Тесты и качество
Минимальный уровень гарантий: юнит/интеграционные, что гоняем в CI.

- [ ] Пример теста (5–10 строк) + команда запуска
- [ ] Статус бейджи (CI, покрытие — если есть)
- [ ] Список «что обязательно тестировать в проде»

## 23) FAQ и разбор типичных проблем
Сэкономим читателю время: ошибки и быстрые фиксы.

- [ ] 5 частых проблем: причина → решение (по 1–2 строки)
- [ ] Ссылки на соответствующие разделы/доки
- [ ] Блок «куда писать, если не помогло» (чат/issue)

## 24) Roadmap и как помочь проекту
Куда идём и как присоединиться.

- [ ] 3–5 плановых фич (с кратким описанием ценности)
- [ ] «Good first issue»/лейблы для новичков
- [ ] Как контрибьютить (1–2 абзаца + ссылка на CONTRIBUTING.md)

## 25) Заключение и Call‑to‑Action
Подведём итог и дадим повод вернуться.

- [ ] Что отдаём читателю: шаблон/демо‑проект/скелет модуля
- [ ] Ссылки: репозиторий, демо, чат/канал, Twitter/Telegram
- [ ] Короткий опрос/форма обратной связи

---

### Рецепт артефактов (как складывать материалы)
- Папка для картинок: `docs/assets/img/` (имена: `01-tldr-arch.png`, `04-quickstart-cli.gif` и т.д.)
- Папка для видео/GIF: `docs/assets/video/` (имена: `05-cli-generate.mp4`)
- Код‑сниппеты держать рядом в `docs/snippets/` (расширения по языку)

### Мини чеклист готовности статьи к публикации
- [ ] Каждому разделу — 1 картинка/сниппет/команда (минимум)
- [ ] Все GIF ≤ 40 секунд, вес оптимизирован
- [ ] Ссылки кликабельны и не ведут на «localhost»
- [ ] Команды проверены в чистой среде
- [ ] В конце — CTA и контакты


